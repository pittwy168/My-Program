POJ1067_取石子游戏
Description
有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。游戏规定，每次有两种不同的取法，一是可以在任意的一堆中取走任意多的石子；二是可以在两堆中同时取走相同数量的石子。最后把石子全部取完者为胜者。现在给出初始的两堆石子的数目，如果轮到你先取，假设双方都采取最好的策略，问最后你是胜者还是败者。
Input
输入包含若干行，表示若干种石子的初始情况，其中每一行包含两个非负整数a和b，表示两堆石子的数目，a和b都不大于1,000,000,000。
Output
输出对应也有若干行，每行包含一个数字1或0，如果最后你是胜者，则为1，反之，则为0。
Sample Input
2 1
8 4
4 7
Sample Output
0
1
0
#Python Beaty 定理
import math
def game1(a,b):
    if a>b:
        a,b=b,a
    d=b-a
    t = math.floor( d * ( math.sqrt(5.0) + 1 ) / 2 )
    if t==a:
        return False
    return True
#Naive 算法-队列
def game2(a,b):
    a,b=min(a,b),max(a,b)
    d,x,y=b-a,1,1
    que=[x+y]
    while a>x and d>y:
        y+=1
        x+=1
        while que and x==que[0]:
            x+=1
            que.pop(0)
        que.append(x+y)
    if b==x+y:
        return False
return True
#C++
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
int main() {
        int a, b, d, t;
       while ( 2 == scanf( "%d%d", &a, &b ) ) {
               if ( a > b ) {t = a; a = b; b = t;}
               d = b - a;
              t = floor( d * ( sqrt(5.0) + 1 ) / 2 );
               puts( (t == a) ? "0" : "1" );
      }return 0;
}

Naive 算法-队列
#include <iostream>
#include <cstdio>

using namespace std;
int main() {
       int a, b, d;
       while ( 2 == scanf( "%d%d", &a, &b ) ) {
               if ( a > b ) { t = a; a = b; b = t;}
               d = b - a;
	int x=1; int y=1;
	std::queue<int> first;
	first.push(x+y);
	while(a>x&&d>y){
	x++;y++;
	while(not first.empty()&&x==first.front()){x++;first.pop();}
	first.push(x+y);}
        puts( (x+y == b) ? "0" : "1" );
      }return 0;
}
